/* tslint:disable */
/* eslint-disable */
/**
 * OpenApi specification - Emmanuel Ofoneta
 * OpenApi documentation for Spring Security
 *
 * The version of the OpenAPI document: 1.0
 * Contact: emmanuelofoneta@gmail.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AuthenticationRequest
 */
export interface AuthenticationRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface AuthenticationResponse
 */
export interface AuthenticationResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface Book
 */
export interface Book {
    /**
     * 
     * @type {number}
     * @memberof Book
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Book
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Book
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Book
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof Book
     */
    'lastModifiedBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof Book
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Book
     */
    'authorName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Book
     */
    'isbn'?: string;
    /**
     * 
     * @type {string}
     * @memberof Book
     */
    'synopsis'?: string;
    /**
     * 
     * @type {string}
     * @memberof Book
     */
    'bookCover'?: string;
    /**
     * 
     * @type {string}
     * @memberof Book
     */
    'bookBackgroundCover'?: string;
    /**
     * 
     * @type {number}
     * @memberof Book
     */
    'pgRating'?: number;
    /**
     * 
     * @type {number}
     * @memberof Book
     */
    'readCount'?: number;
    /**
     * 
     * @type {Array<Genre>}
     * @memberof Book
     */
    'genres'?: Array<Genre>;
    /**
     * 
     * @type {Array<Chapter>}
     * @memberof Book
     */
    'chapters'?: Array<Chapter>;
    /**
     * 
     * @type {boolean}
     * @memberof Book
     */
    'archived'?: boolean;
    /**
     * 
     * @type {User}
     * @memberof Book
     */
    'owner'?: User;
    /**
     * 
     * @type {Array<Feedback>}
     * @memberof Book
     */
    'feedbacks'?: Array<Feedback>;
    /**
     * 
     * @type {number}
     * @memberof Book
     */
    'rate'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Book
     */
    'sharable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Book
     */
    'published'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Book
     */
    'downloadable'?: boolean;
}
/**
 * 
 * @export
 * @interface BookRequest
 */
export interface BookRequest {
    /**
     * 
     * @type {number}
     * @memberof BookRequest
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BookRequest
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof BookRequest
     */
    'authorName': string;
    /**
     * 
     * @type {string}
     * @memberof BookRequest
     */
    'isbn': string;
    /**
     * 
     * @type {string}
     * @memberof BookRequest
     */
    'synopsis': string;
    /**
     * 
     * @type {number}
     * @memberof BookRequest
     */
    'pgRating': number;
    /**
     * 
     * @type {Array<Genre>}
     * @memberof BookRequest
     */
    'genres': Array<Genre>;
    /**
     * 
     * @type {boolean}
     * @memberof BookRequest
     */
    'sharable'?: boolean;
}
/**
 * 
 * @export
 * @interface BookResponse
 */
export interface BookResponse {
    /**
     * 
     * @type {number}
     * @memberof BookResponse
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof BookResponse
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookResponse
     */
    'authorName'?: string;
    /**
     * 
     * @type {Array<Genre>}
     * @memberof BookResponse
     */
    'genres'?: Array<Genre>;
    /**
     * 
     * @type {string}
     * @memberof BookResponse
     */
    'isbn'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookResponse
     */
    'synopsis'?: string;
    /**
     * 
     * @type {string}
     * @memberof BookResponse
     */
    'owner'?: string;
    /**
     * 
     * @type {Array<Chapter>}
     * @memberof BookResponse
     */
    'chapters'?: Array<Chapter>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BookResponse
     */
    'cover'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BookResponse
     */
    'backgroundCover'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof BookResponse
     */
    'numOfChapters'?: number;
    /**
     * 
     * @type {number}
     * @memberof BookResponse
     */
    'rate'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof BookResponse
     */
    'archived'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BookResponse
     */
    'sharable'?: boolean;
}
/**
 * 
 * @export
 * @interface Chapter
 */
export interface Chapter {
    /**
     * 
     * @type {number}
     * @memberof Chapter
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Chapter
     */
    'chapterNum'?: number;
    /**
     * 
     * @type {string}
     * @memberof Chapter
     */
    'chapterName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chapter
     */
    'epigraph'?: string;
    /**
     * 
     * @type {string}
     * @memberof Chapter
     */
    'content'?: string;
    /**
     * 
     * @type {Book}
     * @memberof Chapter
     */
    'book'?: Book;
    /**
     * 
     * @type {Set<User>}
     * @memberof Chapter
     */
    'likes'?: Set<User>;
    /**
     * 
     * @type {Array<Comment>}
     * @memberof Chapter
     */
    'comments'?: Array<Comment>;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof Comment
     */
    'lastModifiedBy'?: number;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'commentText'?: string;
    /**
     * 
     * @type {User}
     * @memberof Comment
     */
    'user'?: User;
    /**
     * 
     * @type {Chapter}
     * @memberof Comment
     */
    'chapter'?: Chapter;
    /**
     * 
     * @type {string}
     * @memberof Comment
     */
    'postedAt'?: string;
}
/**
 * 
 * @export
 * @interface CommentRequest
 */
export interface CommentRequest {
    /**
     * 
     * @type {number}
     * @memberof CommentRequest
     */
    'chapterId'?: number;
    /**
     * 
     * @type {string}
     * @memberof CommentRequest
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface CommentResponse
 */
export interface CommentResponse {
    /**
     * 
     * @type {string}
     * @memberof CommentResponse
     */
    'comment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CommentResponse
     */
    'ownComment'?: boolean;
}
/**
 * 
 * @export
 * @interface Feedback
 */
export interface Feedback {
    /**
     * 
     * @type {number}
     * @memberof Feedback
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof Feedback
     */
    'createdBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof Feedback
     */
    'lastModifiedBy'?: number;
    /**
     * 
     * @type {number}
     * @memberof Feedback
     */
    'note'?: number;
    /**
     * 
     * @type {string}
     * @memberof Feedback
     */
    'comment'?: string;
    /**
     * 
     * @type {Book}
     * @memberof Feedback
     */
    'book'?: Book;
}
/**
 * 
 * @export
 * @interface FeedbackRequest
 */
export interface FeedbackRequest {
    /**
     * 
     * @type {number}
     * @memberof FeedbackRequest
     */
    'note'?: number;
    /**
     * 
     * @type {string}
     * @memberof FeedbackRequest
     */
    'comment': string;
    /**
     * 
     * @type {number}
     * @memberof FeedbackRequest
     */
    'bookId': number;
}
/**
 * 
 * @export
 * @interface FeedbackResponse
 */
export interface FeedbackResponse {
    /**
     * 
     * @type {number}
     * @memberof FeedbackResponse
     */
    'note'?: number;
    /**
     * 
     * @type {string}
     * @memberof FeedbackResponse
     */
    'comment'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FeedbackResponse
     */
    'ownFeedback'?: boolean;
}
/**
 * 
 * @export
 * @interface Genre
 */
export interface Genre {
    /**
     * 
     * @type {number}
     * @memberof Genre
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Genre
     */
    'genreName'?: string;
    /**
     * 
     * @type {Array<Book>}
     * @memberof Genre
     */
    'books'?: Array<Book>;
}
/**
 * 
 * @export
 * @interface GrantedAuthority
 */
export interface GrantedAuthority {
    /**
     * 
     * @type {string}
     * @memberof GrantedAuthority
     */
    'authority'?: string;
}
/**
 * 
 * @export
 * @interface PageResponseBookResponse
 */
export interface PageResponseBookResponse {
    /**
     * 
     * @type {Array<BookResponse>}
     * @memberof PageResponseBookResponse
     */
    'content'?: Array<BookResponse>;
    /**
     * 
     * @type {number}
     * @memberof PageResponseBookResponse
     */
    'number'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseBookResponse
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseBookResponse
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseBookResponse
     */
    'totalPages'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageResponseBookResponse
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageResponseBookResponse
     */
    'last'?: boolean;
}
/**
 * 
 * @export
 * @interface PageResponseCommentResponse
 */
export interface PageResponseCommentResponse {
    /**
     * 
     * @type {Array<CommentResponse>}
     * @memberof PageResponseCommentResponse
     */
    'content'?: Array<CommentResponse>;
    /**
     * 
     * @type {number}
     * @memberof PageResponseCommentResponse
     */
    'number'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseCommentResponse
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseCommentResponse
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseCommentResponse
     */
    'totalPages'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageResponseCommentResponse
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageResponseCommentResponse
     */
    'last'?: boolean;
}
/**
 * 
 * @export
 * @interface PageResponseFeedbackResponse
 */
export interface PageResponseFeedbackResponse {
    /**
     * 
     * @type {Array<FeedbackResponse>}
     * @memberof PageResponseFeedbackResponse
     */
    'content'?: Array<FeedbackResponse>;
    /**
     * 
     * @type {number}
     * @memberof PageResponseFeedbackResponse
     */
    'number'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseFeedbackResponse
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseFeedbackResponse
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageResponseFeedbackResponse
     */
    'totalPages'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageResponseFeedbackResponse
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageResponseFeedbackResponse
     */
    'last'?: boolean;
}
/**
 * 
 * @export
 * @interface RegistrationRequest
 */
export interface RegistrationRequest {
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'dateOfBirth'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'country': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegistrationRequest
     */
    'preferredGenre': Array<string>;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    'lastModifiedDate'?: string;
}
/**
 * 
 * @export
 * @interface SavedBookProperties
 */
export interface SavedBookProperties {
    /**
     * 
     * @type {number}
     * @memberof SavedBookProperties
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof SavedBookProperties
     */
    'bookName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedBookProperties
     */
    'authorName'?: string;
    /**
     * 
     * @type {number}
     * @memberof SavedBookProperties
     */
    'numOfChapters'?: number;
}
/**
 * 
 * @export
 * @interface UploadBookCoverPictureRequest
 */
export interface UploadBookCoverPictureRequest {
    /**
     * 
     * @type {File}
     * @memberof UploadBookCoverPictureRequest
     */
    'file': File;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'dateOfBirth'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'country'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'bio'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'preferredGenre'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'accountLocked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'accountEnabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {Set<User>}
     * @memberof User
     */
    'followers'?: Set<User>;
    /**
     * 
     * @type {Set<User>}
     * @memberof User
     */
    'following'?: Set<User>;
    /**
     * 
     * @type {Array<Role>}
     * @memberof User
     */
    'roles'?: Array<Role>;
    /**
     * 
     * @type {Array<Book>}
     * @memberof User
     */
    'books'?: Array<Book>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'fullName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'accountNonExpired'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'credentialsNonExpired'?: boolean;
    /**
     * 
     * @type {Array<GrantedAuthority>}
     * @memberof User
     */
    'authorities'?: Array<GrantedAuthority>;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'accountNonLocked'?: boolean;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AuthenticationRequest} authenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate: async (authenticationRequest: AuthenticationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authenticationRequest' is not null or undefined
            assertParamExists('authenticate', 'authenticationRequest', authenticationRequest)
            const localVarPath = `/auth/Authenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authenticationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('confirm', 'token', token)
            const localVarPath = `/auth/activate-account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RegistrationRequest} registrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registrationRequest: RegistrationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registrationRequest' is not null or undefined
            assertParamExists('register', 'registrationRequest', registrationRequest)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AuthenticationRequest} authenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authenticate(authenticationRequest: AuthenticationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthenticationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authenticate(authenticationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authenticate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirm(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirm(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.confirm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RegistrationRequest} registrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registrationRequest: RegistrationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registrationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * 
         * @param {AuthenticationRequest} authenticationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(authenticationRequest: AuthenticationRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthenticationResponse> {
            return localVarFp.authenticate(authenticationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirm(token: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.confirm(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RegistrationRequest} registrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registrationRequest: RegistrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.register(registrationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * 
     * @param {AuthenticationRequest} authenticationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticate(authenticationRequest: AuthenticationRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authenticate(authenticationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public confirm(token: string, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).confirm(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RegistrationRequest} registrationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public register(registrationRequest: RegistrationRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).register(registrationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BookApi - axios parameter creator
 * @export
 */
export const BookApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllBooks: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/books/all-books`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllBooksByOwner: async (page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/books/owner`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBookById: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findBookById', 'id', id)
            const localVarPath = `/books/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFanFavorites: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/books/fan-favorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMostReadBooks: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/books/most-read`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readBook: async (id: number, name: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('readBook', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('readBook', 'name', name)
            const localVarPath = `/books/{id}/{name}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"name"}}`, encodeURIComponent(String(name)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BookRequest} bookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveBook: async (bookRequest: BookRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookRequest' is not null or undefined
            assertParamExists('saveBook', 'bookRequest', bookRequest)
            const localVarPath = `/books`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArchivedStatus: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateArchivedStatus', 'id', id)
            const localVarPath = `/books/archived/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSharableStatus: async (id: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSharableStatus', 'id', id)
            const localVarPath = `/books/sharable/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UploadBookCoverPictureRequest} [uploadBookCoverPictureRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBookBackgroundPicture: async (id: number, uploadBookCoverPictureRequest?: UploadBookCoverPictureRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadBookBackgroundPicture', 'id', id)
            const localVarPath = `/books/background-cover/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadBookCoverPictureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {UploadBookCoverPictureRequest} [uploadBookCoverPictureRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBookCoverPicture: async (id: number, uploadBookCoverPictureRequest?: UploadBookCoverPictureRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('uploadBookCoverPicture', 'id', id)
            const localVarPath = `/books/cover/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadBookCoverPictureRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BookApi - functional programming interface
 * @export
 */
export const BookApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BookApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllBooks(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageResponseBookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllBooks(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.findAllBooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllBooksByOwner(page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageResponseBookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllBooksByOwner(page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.findAllBooksByOwner']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findBookById(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findBookById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.findBookById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFanFavorites(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Book>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFanFavorites(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.getFanFavorites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMostReadBooks(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Book>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMostReadBooks(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.getMostReadBooks']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readBook(id: number, name: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readBook(id, name, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.readBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {BookRequest} bookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveBook(bookRequest: BookRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedBookProperties>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveBook(bookRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.saveBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateArchivedStatus(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateArchivedStatus(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.updateArchivedStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSharableStatus(id: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSharableStatus(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.updateSharableStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {UploadBookCoverPictureRequest} [uploadBookCoverPictureRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadBookBackgroundPicture(id: number, uploadBookCoverPictureRequest?: UploadBookCoverPictureRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadBookBackgroundPicture(id, uploadBookCoverPictureRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.uploadBookBackgroundPicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {UploadBookCoverPictureRequest} [uploadBookCoverPictureRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadBookCoverPicture(id: number, uploadBookCoverPictureRequest?: UploadBookCoverPictureRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadBookCoverPicture(id, uploadBookCoverPictureRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BookApi.uploadBookCoverPicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BookApi - factory interface
 * @export
 */
export const BookApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BookApiFp(configuration)
    return {
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllBooks(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageResponseBookResponse> {
            return localVarFp.findAllBooks(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllBooksByOwner(page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageResponseBookResponse> {
            return localVarFp.findAllBooksByOwner(page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBookById(id: number, options?: RawAxiosRequestConfig): AxiosPromise<BookResponse> {
            return localVarFp.findBookById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFanFavorites(options?: RawAxiosRequestConfig): AxiosPromise<Array<Book>> {
            return localVarFp.getFanFavorites(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMostReadBooks(options?: RawAxiosRequestConfig): AxiosPromise<Array<Book>> {
            return localVarFp.getMostReadBooks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readBook(id: number, name: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.readBook(id, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BookRequest} bookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveBook(bookRequest: BookRequest, options?: RawAxiosRequestConfig): AxiosPromise<SavedBookProperties> {
            return localVarFp.saveBook(bookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateArchivedStatus(id: number, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.updateArchivedStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSharableStatus(id: number, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.updateSharableStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UploadBookCoverPictureRequest} [uploadBookCoverPictureRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBookBackgroundPicture(id: number, uploadBookCoverPictureRequest?: UploadBookCoverPictureRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.uploadBookBackgroundPicture(id, uploadBookCoverPictureRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {UploadBookCoverPictureRequest} [uploadBookCoverPictureRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadBookCoverPicture(id: number, uploadBookCoverPictureRequest?: UploadBookCoverPictureRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.uploadBookCoverPicture(id, uploadBookCoverPictureRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BookApi - object-oriented interface
 * @export
 * @class BookApi
 * @extends {BaseAPI}
 */
export class BookApi extends BaseAPI {
    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public findAllBooks(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).findAllBooks(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public findAllBooksByOwner(page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).findAllBooksByOwner(page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public findBookById(id: number, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).findBookById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public getFanFavorites(options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).getFanFavorites(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public getMostReadBooks(options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).getMostReadBooks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public readBook(id: number, name: string, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).readBook(id, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BookRequest} bookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public saveBook(bookRequest: BookRequest, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).saveBook(bookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public updateArchivedStatus(id: number, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).updateArchivedStatus(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public updateSharableStatus(id: number, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).updateSharableStatus(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UploadBookCoverPictureRequest} [uploadBookCoverPictureRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public uploadBookBackgroundPicture(id: number, uploadBookCoverPictureRequest?: UploadBookCoverPictureRequest, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).uploadBookBackgroundPicture(id, uploadBookCoverPictureRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {UploadBookCoverPictureRequest} [uploadBookCoverPictureRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BookApi
     */
    public uploadBookCoverPicture(id: number, uploadBookCoverPictureRequest?: UploadBookCoverPictureRequest, options?: RawAxiosRequestConfig) {
        return BookApiFp(this.configuration).uploadBookCoverPicture(id, uploadBookCoverPictureRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChapterControllerApi - axios parameter creator
 * @export
 */
export const ChapterControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} userId 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeChapter: async (userId: number, chapterId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('likeChapter', 'userId', userId)
            // verify required parameter 'chapterId' is not null or undefined
            assertParamExists('likeChapter', 'chapterId', chapterId)
            const localVarPath = `/chapter/{chapter_id}/like/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"chapter_id"}}`, encodeURIComponent(String(chapterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeChapter: async (userId: number, chapterId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('unlikeChapter', 'userId', userId)
            // verify required parameter 'chapterId' is not null or undefined
            assertParamExists('unlikeChapter', 'chapterId', chapterId)
            const localVarPath = `/chapter/{chapter_id}/unLike/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"chapter_id"}}`, encodeURIComponent(String(chapterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChapterControllerApi - functional programming interface
 * @export
 */
export const ChapterControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChapterControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async likeChapter(userId: number, chapterId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.likeChapter(userId, chapterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChapterControllerApi.likeChapter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unlikeChapter(userId: number, chapterId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unlikeChapter(userId, chapterId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChapterControllerApi.unlikeChapter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChapterControllerApi - factory interface
 * @export
 */
export const ChapterControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChapterControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        likeChapter(userId: number, chapterId: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.likeChapter(userId, chapterId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} chapterId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlikeChapter(userId: number, chapterId: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.unlikeChapter(userId, chapterId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChapterControllerApi - object-oriented interface
 * @export
 * @class ChapterControllerApi
 * @extends {BaseAPI}
 */
export class ChapterControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} userId 
     * @param {number} chapterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChapterControllerApi
     */
    public likeChapter(userId: number, chapterId: number, options?: RawAxiosRequestConfig) {
        return ChapterControllerApiFp(this.configuration).likeChapter(userId, chapterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} chapterId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChapterControllerApi
     */
    public unlikeChapter(userId: number, chapterId: number, options?: RawAxiosRequestConfig) {
        return ChapterControllerApiFp(this.configuration).unlikeChapter(userId, chapterId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CommentControllerApi - axios parameter creator
 * @export
 */
export const CommentControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CommentRequest} commentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addComment: async (commentRequest: CommentRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'commentRequest' is not null or undefined
            assertParamExists('addComment', 'commentRequest', commentRequest)
            const localVarPath = `/comments/add_comment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(commentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentByChapterId: async (id: number, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCommentByChapterId', 'id', id)
            const localVarPath = `/comments/chapter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommentControllerApi - functional programming interface
 * @export
 */
export const CommentControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommentControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CommentRequest} commentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addComment(commentRequest: CommentRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addComment(commentRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentControllerApi.addComment']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} id 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommentByChapterId(id: number, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageResponseCommentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCommentByChapterId(id, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CommentControllerApi.getCommentByChapterId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CommentControllerApi - factory interface
 * @export
 */
export const CommentControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommentControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CommentRequest} commentRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addComment(commentRequest: CommentRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.addComment(commentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentByChapterId(id: number, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageResponseCommentResponse> {
            return localVarFp.getCommentByChapterId(id, page, size, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommentControllerApi - object-oriented interface
 * @export
 * @class CommentControllerApi
 * @extends {BaseAPI}
 */
export class CommentControllerApi extends BaseAPI {
    /**
     * 
     * @param {CommentRequest} commentRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentControllerApi
     */
    public addComment(commentRequest: CommentRequest, options?: RawAxiosRequestConfig) {
        return CommentControllerApiFp(this.configuration).addComment(commentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommentControllerApi
     */
    public getCommentByChapterId(id: number, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return CommentControllerApiFp(this.configuration).getCommentByChapterId(id, page, size, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FeedbacksApi - axios parameter creator
 * @export
 */
export const FeedbacksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} id 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findALlFeedbacksByBook: async (id: number, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('findALlFeedbacksByBook', 'id', id)
            const localVarPath = `/feedbacks/books/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FeedbackRequest} feedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFeedBack: async (feedbackRequest: FeedbackRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedbackRequest' is not null or undefined
            assertParamExists('saveFeedBack', 'feedbackRequest', feedbackRequest)
            const localVarPath = `/feedbacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feedbackRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedbacksApi - functional programming interface
 * @export
 */
export const FeedbacksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedbacksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findALlFeedbacksByBook(id: number, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageResponseFeedbackResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findALlFeedbacksByBook(id, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedbacksApi.findALlFeedbacksByBook']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {FeedbackRequest} feedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveFeedBack(feedbackRequest: FeedbackRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveFeedBack(feedbackRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FeedbacksApi.saveFeedBack']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FeedbacksApi - factory interface
 * @export
 */
export const FeedbacksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedbacksApiFp(configuration)
    return {
        /**
         * 
         * @param {number} id 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findALlFeedbacksByBook(id: number, page?: number, size?: number, options?: RawAxiosRequestConfig): AxiosPromise<PageResponseFeedbackResponse> {
            return localVarFp.findALlFeedbacksByBook(id, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FeedbackRequest} feedbackRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveFeedBack(feedbackRequest: FeedbackRequest, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.saveFeedBack(feedbackRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedbacksApi - object-oriented interface
 * @export
 * @class FeedbacksApi
 * @extends {BaseAPI}
 */
export class FeedbacksApi extends BaseAPI {
    /**
     * 
     * @param {number} id 
     * @param {number} [page] 
     * @param {number} [size] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbacksApi
     */
    public findALlFeedbacksByBook(id: number, page?: number, size?: number, options?: RawAxiosRequestConfig) {
        return FeedbacksApiFp(this.configuration).findALlFeedbacksByBook(id, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FeedbackRequest} feedbackRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbacksApi
     */
    public saveFeedBack(feedbackRequest: FeedbackRequest, options?: RawAxiosRequestConfig) {
        return FeedbacksApiFp(this.configuration).saveFeedBack(feedbackRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} userId 
         * @param {number} userToFollow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser: async (userId: number, userToFollow: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('followUser', 'userId', userId)
            // verify required parameter 'userToFollow' is not null or undefined
            assertParamExists('followUser', 'userToFollow', userToFollow)
            const localVarPath = `/user/{userId}/follow/{userToFollow}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"userToFollow"}}`, encodeURIComponent(String(userToFollow)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowers: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getFollowers', 'userId', userId)
            const localVarPath = `/user/{userId}/followers`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowings: async (userId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getFollowings', 'userId', userId)
            const localVarPath = `/user/{userId}/followings`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} userToUnFollow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unFollowUser: async (userId: number, userToUnFollow: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('unFollowUser', 'userId', userId)
            // verify required parameter 'userToUnFollow' is not null or undefined
            assertParamExists('unFollowUser', 'userToUnFollow', userToUnFollow)
            const localVarPath = `/user/{userId}/unfollow/{userToUnFollow}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"userToUnFollow"}}`, encodeURIComponent(String(userToUnFollow)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "bearerAuth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {number} userToFollow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followUser(userId: number, userToFollow: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followUser(userId, userToFollow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.followUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowers(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowers(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getFollowers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFollowings(userId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFollowings(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getFollowings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} userToUnFollow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unFollowUser(userId: number, userToUnFollow: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unFollowUser(userId, userToUnFollow, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.unFollowUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {number} userId 
         * @param {number} userToFollow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser(userId: number, userToFollow: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.followUser(userId, userToFollow, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowers(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Set<User>> {
            return localVarFp.getFollowers(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFollowings(userId: number, options?: RawAxiosRequestConfig): AxiosPromise<Set<User>> {
            return localVarFp.getFollowings(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} userId 
         * @param {number} userToUnFollow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unFollowUser(userId: number, userToUnFollow: number, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.unFollowUser(userId, userToUnFollow, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @param {number} userId 
     * @param {number} userToFollow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public followUser(userId: number, userToFollow: number, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).followUser(userId, userToFollow, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getFollowers(userId: number, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getFollowers(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getFollowings(userId: number, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getFollowings(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} userId 
     * @param {number} userToUnFollow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public unFollowUser(userId: number, userToUnFollow: number, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).unFollowUser(userId, userToUnFollow, options).then((request) => request(this.axios, this.basePath));
    }
}



